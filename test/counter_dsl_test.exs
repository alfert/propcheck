defmodule PropCheck.Test.CounterDSL do
  @moduledoc """
  This is a test of the modulo counter. There are several variants of test
  setups, to check that the DSL implementation is capable of shrinking
  failures due to ignoring the modulo features to a minimal set of steps.

  The state machine model of the counter has only three states:
      * `init`: the counter is initialized
      * `zero`: the counter is reset to `0`
      * `one`: the counter has a value above `0`

  These states are reflected in the commands and for determining the
  weights of the commands.
  """
  use PropCheck, default_opts: &PropCheck.TestHelpers.config/0
  use PropCheck.StateM.ModelDSL
  use ExUnit.Case, async: true
  import ExUnit.CaptureIO
  require Logger

  alias PropCheck.Test.Counter

  @moduletag capture_log: true

  #########################################################################
  ### The properties
  #########################################################################

  property "infinity counter works fine" do
    forall cmds <- commands(__MODULE__) do
      trap_exit do
        {:ok, _pid} = Counter.start_link()
        r = run_commands(__MODULE__, cmds)
        {_history, _state, result} = r
        Counter.stop()

        (result == :ok)
        |> when_fail(print_report(r, cmds))

        # |> aggregate(command_names cmds)
        # |> measure("length of commands", length(cmds))
      end
    end
  end

  @tag will_fail: true
  property "modulo counter does not increment infinite times" do
    Logger.error("This property will fail in order to show the shrinking results")
    Logger.error("It is excluded from the set of test for the travis build")

    forall cmds <- commands(__MODULE__) do
      trap_exit do
        {:ok, _pid} = Counter.start_link(5)
        r = run_commands(__MODULE__, cmds)
        {_history, _state, result} = r
        Counter.stop()

        (result == :ok)
        |> when_fail(print_report(r, cmds))

        # |> aggregate(command_names cmds)
        # |> measure("length of commands", length(cmds))
      end
    end
  end

  #########################################################################
  ### Some tests of command generation and shrinking
  #########################################################################

  test "shrink the commands" do
    shrinkings = capture_io(fn -> sample_shrink(commands(__MODULE__), 10) end)
    # Ensure that each list of commands begins with the sequence '[{init,'
    # this means that (except for the empty list) only command sequences
    # which start in state `:init` are generated by shrinking.
    cmd_matcher = ~r/^(\[{init,)|(\[\])|( ).*/
    {:ok, shrinks} = StringIO.open(shrinkings)

    assert shrinks
           |> IO.stream(:line)
           |> Enum.all?(&Regex.match?(cmd_matcher, &1))
  end

  #########################################################################
  ### The model
  #########################################################################

  def initial_state, do: :init

  def command_gen(:init),
    do:
      oneof([
        {:inc, []},
        {:clear, []}
      ])

  def command_gen(_),
    do:
      frequency([
        {1, {:get, []}},
        {2, {:inc, []}},
        {1, {:clear, []}}
      ])

  defcommand :inc do
    def impl, do: Counter.inc()
    def next(:init, [], _res), do: :zero
    def next(:zero, [], _res), do: :one
    def next(:one, [], _res), do: :one
    def post(:init, [], res), do: res == 0
    def post(:zero, [], res), do: res > 0
    def post(:one, [], res), do: res > 0
  end

  defcommand :get do
    def impl, do: Counter.get()
    def post(_state, [], res), do: res >= 0
    def pre(:init, _, _), do: false
    def pre(_, _, _), do: true
  end

  defcommand :clear do
    def impl, do: Counter.clear()
    def next(_state, [], _res), do: :zero
    def post(_state, [], res), do: res == :ok
  end
end
