defmodule PropCheck.DeriveGenerators.Expand do
  @moduledoc false

  alias PropCheck.DeriveGenerators.NotSupported

  # Returns a list [{name, generator}], where name is the name of a generator
  # which does not receive any arguments. If a generator expects arguments,
  # name == nil.
  def expand({:type, {name, type, args}}) when args == [] or args == 0 do
    inner = expand_inner(type)

    generator =
      quote do
        def unquote(name)() do
          unquote(inner)
        end
      end

    {name, generator}
  end

  # {:type, {:lists, {:type, 32, :list, [{:var, 32, :type}]}, [{:var, 32, :type}]}}
  def expand({:type, {name, type, type_vars}}) do
    vars =
      for {:var, _, var_name} <- type_vars do
        Macro.var(var_name, nil)
      end

    inner = expand_inner(type)

    generator =
      quote do
        def unquote(name)(unquote_splicing(vars)) do
          unquote(inner)
        end
      end

    {nil, generator}
  end

  @basic_non_parametrized [
    :any,
    :term,
    :boolean,
    :bool,
    :byte,
    :char,
    :atom,
    # :map, is parametrized in PropEr
    # :pid, cannot be generated by PropEr
    # :port, cannot be generated by PropEr
    # :reference, cannot be generated by PropEr
    # :struct, struct() is a remote type
    # :tuple, must be handled specially
    :integer,
    :float,
    :neg_integer,
    :non_neg_integer,
    :pos_integer,
    :number
  ]

  @atom_alias [:node, :module]

  #
  # Basic Types
  #

  defp expand_inner({:type, _, basic_type, _}) when basic_type in @basic_non_parametrized do
    quote do
      unquote(basic_type)()
    end
  end

  # {:type, 21, :tuple, :any}
  defp expand_inner({:type, _, :tuple, :any}) do
    quote do
      tuple()
    end
  end

  # {:type, 14, :map, :any}
  defp expand_inner({:type, _, :map, :any}) do
    quote do
      map(any(), any())
    end
  end

  # {:type, 33, :nonempty_lists, [{:var, 33, :type}]}
  defp expand_inner({:type, _, :nonempty_list, [inner]}) do
    inner_expanded = expand_inner(inner)

    quote do
      non_empty([unquote(inner_expanded)])
    end
  end

  # {:type, 101, :maybe_improper_list, []}
  defp expand_inner({:type, loc, :maybe_improper_list, []}) do
    expand_inner(
      {:type, loc, :maybe_improper_list, [{:type, loc, :any, []}, {:type, loc, :any, []}]}
    )
  end

  # {:type, 34, :maybe_improper_list, [{:var, 34, :type1}, {:var, 34, :type2}]}
  defp expand_inner({:type, _, :maybe_improper_list, [inner1, inner2]}) do
    inner1_expanded = expand_inner(inner1)
    inner2_expanded = expand_inner(inner2)

    quote do
      let [
        front <- list(unquote(inner1_expanded)),
        back <- oneof([nil, unquote(inner2_expanded)])
      ] do
        if is_nil(back) do
          front
        else
          # if front is empty, we cannot create an improper list.
          case front do
            [] ->
              []

            _ ->
              [h | t] = front |> Enum.reverse()
              Enum.reverse(t) ++ [h | back]
          end
        end
      end
    end
  end

  # {:type, 35, :nonempty_improper_list, [{:var, 35, :type1}, {:var, 35, :type2}]}
  defp expand_inner({:type, _, :nonempty_improper_list, [inner1, inner2]}) do
    inner1_expanded = expand_inner(inner1)
    inner2_expanded = expand_inner(inner2)

    quote do
      let [
        front <- non_empty(list(unquote(inner1_expanded))),
        back <- unquote(inner2_expanded)
      ] do
        [h | t] = front |> Enum.reverse()
        Enum.reverse(t) ++ [h | back]
      end
    end
  end

  # {:type, 101, :nonempty_maybe_improper_list, []}
  defp expand_inner({:type, loc, :nonempty_maybe_improper_list, []}) do
    expand_inner(
      {:type, loc, :nonempty_maybe_improper_list,
       [{:type, loc, :any, []}, {:type, loc, :any, []}]}
    )
  end

  # {:type, 36, :nonempty_maybe_improper_list, [{:var, 36, :type1}, {:var, 36, :type2}]}
  defp expand_inner({:type, loc, :nonempty_maybe_improper_list, args}) do
    maybe_empty = expand_inner({:type, loc, :maybe_improper_list, args})

    quote do
      non_empty(unquote(maybe_empty))
    end
  end

  #
  # Literals
  #

  # {:atom, 0, :atom}
  defp expand_inner({:atom, _, const}) do
    const
  end

  # {:type, 43, :binary, [{:integer, 43, 0}, {:integer, 43, 0}]}
  # {:type, 45, :binary, [{:integer, 45, 5}, {:integer, 45, 0}]}
  defp expand_inner({:type, _, :binary, [{:integer, _, size}, {:integer, _, 0}]}) do
    quote do
      bitstring(unquote(size))
    end
  end

  # {:type, 46, :binary, [{:integer, 46, 0}, {:integer, 46, 10}]}
  defp expand_inner({:type, _, :binary, [{:integer, _, 0}, {:integer, _, unit}]}) do
    quote do
      let size <- non_neg_integer() do
        bitstring(size * unquote(unit))
      end
    end
  end

  # {:type, 47, :binary, [{:integer, 47, 5}, {:integer, 47, 10}]}
  defp expand_inner({:type, _, :binary, [{:integer, _, size}, {:integer, _, unit}]}) do
    quote do
      bitstring(unquote(size) * unquote(unit))
    end
  end

  # {:type, 50, :fun, [{:type, 50, :product, []}, {:type, 50, :any, []}]}
  # {:type, 54, :fun, [{:type, 54, :product, [
  #     {:type, 54, :any, []},
  #     {:type, 54, :any, []}
  #   ]},
  #   {:type, 54, :any, []}
  # ]}
  defp expand_inner({:type, _, :fun, [{:type, _, :product, arguments}, result]}) do
    argument_types = Enum.map(arguments, &expand_inner/1)
    result_type = expand_inner(result)

    quote do
      function(unquote(argument_types), unquote(result_type))
    end
  end

  # {:type, 0, nil, []}
  defp expand_inner({:type, _, nil, []}) do
    quote do
      []
    end
  end

  # {:type, 62, :map, []}
  # {:type, 72, :map, [
  #   {:type, 72, :map_field_exact, [{:atom, 0, :__struct__}, {:atom, 0, SampleModule.SomeStruct}]}]}
  # {:type, 69, :map, [
  #   {:type, 69, :map_field_exact, [{:atom, 0, :key1}, {:var, 69, :type1}]},
  #   {:type, 69, :map_field_exact, [{:atom, 0, :key2}, {:var, 69, :type2}]}]}
  # {:type, 71, :map, [
  #   {:type, 71, :map_field_assoc,
  #    [{:var, 71, :key_type}, {:var, 71, :value_type}]}]}
  defp expand_inner({:type, _, :map, inner}) do
    exact_expanded =
      for {:type, _, :map_field_exact, [key, type]} <- inner do
        {expand_inner(key), expand_inner(type)}
      end

    assoc_expanded =
      for {:type, _, :map_field_assoc, [key, type]} <- inner do
        {expand_inner(key), expand_inner(type)}
      end

    quote do
      let [kw_exact <- unquote(exact_expanded), kw_assoc <- oneof([[], unquote(assoc_expanded)])] do
        Map.new(kw_exact ++ kw_assoc)
      end
    end
  end

  # {:type, 71, :tuple, []}
  # {:type, 0, :tuple, [{:atom, 0, :ok}, {:type, 75, :any, []}]}
  defp expand_inner({:type, _, :tuple, inner}) do
    inner_expanded = Enum.map(inner, &expand_inner/1)

    quote do
      {unquote_splicing(inner_expanded)}
    end
  end

  # {:type, 98, :list, []}
  defp expand_inner({:type, loc, :list, []}) do
    expand_inner({:type, loc, :list, [{:type, loc, :any, []}]})
  end

  # {:type, 30, :list, [{:type, 30, :integer, []}]}
  defp expand_inner({:type, _, :list, [inner]}) do
    inner_expanded = expand_inner(inner)

    quote do
      [unquote(inner_expanded)]
    end
  end

  # {:type, 0, :nonempty_list, []}
  defp expand_inner({:type, _, :nonempty_list, []}) do
    quote do
      non_empty([any()])
    end
  end

  #
  # Built-In
  #

  # {:type, 103, :mfa, []}
  defp expand_inner({:type, _, :mfa, []}) do
    quote do
      {atom(), atom(), non_neg_integer()}
    end
  end

  # {:type, 105, :node, []}
  defp expand_inner({:type, _, type, []}) when type in @atom_alias do
    quote do
      atom()
    end
  end

  # {:type, 108, :timeout, []}
  defp expand_inner({:type, _, :timeout, []}) do
    quote do
      oneof([:infinity, non_neg_integer()])
    end
  end

  # {:type, 85, :binary, []}
  defp expand_inner({:type, _, :binary, []}) do
    quote do
      binary()
    end
  end

  # {:type, 83, :bitstring, []}
  defp expand_inner({:type, _, :bitstring, []}) do
    quote do
      bitstring()
    end
  end

  # {:type, 80, :arity, []}
  defp expand_inner({:type, _, :arity, []}) do
    quote do
      integer(0, 255)
    end
  end

  #
  # Remote
  #

  # {:remote_type, 0, [{:atom, 0, :elixir}, {:atom, 0, :struct}, []]}
  defp expand_inner({:remote_type, _, [{:atom, _, :elixir}, {:atom, _, :struct}, []]}) do
    quote do
      let [
        m <- map(any(), any()),
        name <- atom()
      ] do
        Map.put(m, :__struct__, name)
      end
    end
  end

  # {:remote_type, 0, [{:atom, 0, :elixir}, {:atom, 0, :as_boolean}, [{:var, 81, :t}]]}
  defp expand_inner({:remote_type, _, [{:atom, _, :elixir}, {:atom, _, :as_boolean}, [inner]]}) do
    inner_expanded = expand_inner(inner)

    quote do
      unquote(inner_expanded)
    end
  end

  # {:remote_type, 0, [{:atom, 0, :elixir}, {:atom, 0, :charlist}, []]}
  # charlist() parses as a remote type, but is actually an alias
  defp expand_inner({:remote_type, _, [{:atom, _, :elixir}, {:atom, _, :charlist}, []]}) do
    quote do
      [char()]
    end
  end

  # {:remote_type, 0, [{:atom, 0, :elixir}, {:atom, 0, :nonempty_charlist}, []]}
  defp expand_inner({:remote_type, _, [{:atom, _, :elixir}, {:atom, _, :nonempty_charlist}, []]}) do
    quote do
      non_empty([char()])
    end
  end

  # {:remote_type, 0, [{:atom, 0, :elixir}, {:atom, 0, :keyword}, []]}
  defp expand_inner({:remote_type, _, [{:atom, _, :elixir}, {:atom, _, :keyword}, []]}) do
    quote do
      [{atom(), any()}]
    end
  end

  # {:remote_type, 0, [{:atom, 0, :elixir}, {:atom, 0, :keyword}, [{:var, 95, :type}]]}
  defp expand_inner({:remote_type, _, [{:atom, _, :elixir}, {:atom, _, :keyword}, [inner]]}) do
    inner_expanded = expand_inner(inner)

    quote do
      [{atom(), unquote(inner_expanded)}]
    end
  end

  # {:remote_type, 115, [{:atom, 0, String}, {:atom, 0, :t}, []]}
  defp expand_inner({:remote_type, _, [{:atom, _, module}, {:atom, _, type}, []]})
       when module != :elixir do
    remote_generator = Module.concat(module, :Generate)

    quote do
      unquote(remote_generator).unquote(type)()
    end
  end

  # {:remote_type, 113, [{:atom, 0, Keyword}, {:atom, 0, :t}, [{:var, 113, :type}]]}
  defp expand_inner({:remote_type, _, [{:atom, 0, module}, {:atom, 0, type}, type_args]})
       when module != :elixir do
    type_args_expanded = Enum.map(type_args, &expand_inner/1)
    remote_generator = Module.concat(module, :Generate)

    quote do
      unquote(remote_generator).unquote(type)(unquote_splicing(type_args_expanded))
    end
  end

  #
  # Union
  #

  # {:type, 43, :union, [{:atom, 0, true}, {:atom, 0, false}, {:atom, 0, nil}]}
  defp expand_inner({:type, _, :union, variants}) do
    variants_expanded = Enum.map(variants, &expand_inner/1)

    quote do
      oneof([unquote_splicing(variants_expanded)])
    end
  end

  #
  # Type Variables
  #
  # {:var, 32, :type}
  defp expand_inner({:var, _, var_name}) do
    Macro.var(var_name, nil)
  end

  #
  # User Types
  #

  # {:user_type, 82, :key, []}
  defp expand_inner({:user_type, _, type, []}) do
    quote do
      __MODULE__.unquote(type)()
    end
  end

  #
  # Unsupported
  #

  # {:type, 10, :none, []}
  defp expand_inner({:type, _, :none, []}) do
    raise NotSupported, type: "none()", reason: "can't generate"
  end

  # {:type, 19, :pid, []}
  defp expand_inner({:type, _, :pid, []}) do
    raise NotSupported, type: "pid()", reason: "can't generate"
  end

  # {:type, 19, :port, []}
  defp expand_inner({:type, _, :port, []}) do
    raise NotSupported, type: "port()", reason: "can't generate"
  end

  # {:type, 20, :reference, []}
  defp expand_inner({:type, _, :reference, []}) do
    raise NotSupported, type: "reference()", reason: "can't generate"
  end

  # {:type, 55, :fun, []}
  defp expand_inner({:type, _, :fun, []}) do
    raise NotSupported, type: "(... -> type())", reason: "can't generate"
  end

  # {:type, 91, :function, []}
  defp expand_inner({:type, _, :function, []}) do
    raise NotSupported, type: "function()", reason: "can't generate (... -> any())"
  end

  # {:type, 105, :no_return, []}
  defp expand_inner({:type, _, :no_return, []}) do
    raise NotSupported, type: "no_return()", reason: "can't generate none()"
  end

  # {:type, 92, :identifier, []}
  defp expand_inner({:type, _, :identifier, []}) do
    raise NotSupported,
      type: "identifier()",
      reason: "can't generate pid() | port() | reference()"
  end

  # {:type, 94, :iolist, []}
  defp expand_inner({:type, _, :iolist, []}) do
    raise NotSupported, type: "iolist()", reason: "can't generate recursive generator"
  end

  # {:type, 92, :iodata, []}
  defp expand_inner({:type, _, :iodata, []}) do
    raise NotSupported, type: "iodata()", reason: "can't generate recursive generator"
  end
end
